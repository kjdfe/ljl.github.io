WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.809
我注意到 C++ 方法或函数的一个有趣的地方

00:00:05.809 --> 00:00:08.369
实际上我是偶然发现的

00:00:08.369 --> 00:00:12.649
当我写了两个相同名字的函数时 让我看看还能不能找到

00:00:12.650 --> 00:00:16.240
我写了两个名字很接近的函数

00:00:16.239 --> 00:00:18.289
其中一个函数目的在于比较两个单精度浮点数

00:00:18.289 --> 00:00:22.660
Chino 可以看到这两个函数的浮点接近 不过并非完全相同

00:00:22.660 --> 00:00:23.740
在两个函数浮点接近的情况下

00:00:23.739 --> 00:00:25.417
我想返回 true 

00:00:25.417 --> 00:00:26.844
另外一个函数目的在于两个网格

00:00:26.844 --> 00:00:29.949
如果这两个函数足够接近于完全相同 那么我想返回 true

00:00:29.949 --> 00:00:33.615
这说明里面的所有实际值都足够接近

00:00:33.615 --> 00:00:35.130
我让其他人这样做过

00:00:35.130 --> 00:00:36.690
我不敢相信这居然有效

00:00:36.689 --> 00:00:42.534
但是结果足够接近 或者采取了两个向量浮点或网格

00:00:42.534 --> 00:00:45.149
和另一个版本或两个单精度浮点

00:00:45.149 --> 00:00:46.234
这是为什么呢

00:00:46.234 --> 00:00:47.640
为什么会这是允许的？

00:00:47.640 --> 00:00:50.289
编译器并不把它们看做完全相同的

00:00:50.289 --> 00:00:52.174
因为两者签名完全不同

00:00:52.174 --> 00:00:53.439
我的意思是说 如果你签了字

00:00:53.439 --> 00:00:55.304
我也签了字 我们的签名肯定是不一样的

00:00:55.304 --> 00:01:01.000
编译器会读取这些函数和他们的类型

00:01:01.000 --> 00:01:05.635
它读取了这个足够接近的向量网格

00:01:05.635 --> 00:01:09.500
使它成为函数名称的一部分

00:01:09.500 --> 00:01:11.420
在这里你看不到

00:01:11.420 --> 00:01:14.320
但是如果你看编译器内部

00:01:14.319 --> 00:01:18.744
你可以看到它从哪里开始处理采用名称定义的

00:01:18.745 --> 00:01:22.030
所有函数

00:01:22.030 --> 00:01:24.099
和所有参数的

00:01:24.099 --> 00:01:25.649
所以这就是所谓的超载

00:01:25.650 --> 00:01:29.200
如果你想拥有一个在浮点上或者整数

00:01:29.200 --> 00:01:33.055
上足够接近的函数这可能非常有用

00:01:33.055 --> 00:01:37.805
你不用做任何非常的特殊事情

00:01:37.805 --> 00:01:40.098
你必须有很多不同的函数名

00:01:40.097 --> 00:01:42.875
你希望它知道是否足够接近

00:01:42.875 --> 00:01:44.314
这是人的特征

00:01:44.314 --> 00:01:46.120
不 我觉得这样做真的很好

