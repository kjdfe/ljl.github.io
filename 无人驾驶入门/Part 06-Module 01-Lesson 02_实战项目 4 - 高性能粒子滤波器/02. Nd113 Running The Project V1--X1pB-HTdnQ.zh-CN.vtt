WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.805
大家好 我是 Andrew Pastor

00:00:02.805 --> 00:00:09.780
我是无人驾驶纳米学位课程的内容开发人员

00:00:09.780 --> 00:00:17.445
以前就想做一个关于 C++ 优化项目的入门课程

00:00:17.445 --> 00:00:20.085
在这个纳米学位项目中

00:00:20.085 --> 00:00:25.785
你将得到一个 C++ 直方图过滤器代码 而且它已经工作了

00:00:25.785 --> 00:00:27.285
所以你可以运行它

00:00:27.285 --> 00:00:30.790
它运行正常 一切都很好

00:00:30.790 --> 00:00:36.640
但这个代码有很多效率低下的问题

00:00:36.640 --> 00:00:41.410
所以 你在这个优化课程中学到的一切

00:00:41.410 --> 00:00:45.640
都可以应用到此代码 目的是使其运行得更快

00:00:45.640 --> 00:00:51.160
关于这个项目的一个有趣的部分是 很多学生将要去 Slack 上

00:00:51.160 --> 00:00:53.575
并且会在上面相互竞争

00:00:53.575 --> 00:00:56.680
比一比他们完成编码的速度有多快

00:00:56.680 --> 00:00:59.185
所以 如果你要做好这次挑战的准备

00:00:59.185 --> 00:01:04.715
完成后 去 Slack 上并将你的结果发布到 C++ 板块中

00:01:04.715 --> 00:01:08.240
另外我再提一下 这个项目是不评分的

00:01:08.240 --> 00:01:15.900
所以做不做这个项目并达到你想要的程度 这都取决于你

00:01:15.900 --> 00:01:19.710
最后 我们会提供了一个参考答案

00:01:19.710 --> 00:01:23.535
你可以把你的结果与之作比较 但是需要提醒的是 它也是不评分的

00:01:23.535 --> 00:01:27.786
所以 让我们来看看这个项目 看看我们在这里要学习什么

00:01:27.786 --> 00:01:29.456
当你打开该项目时

00:01:29.456 --> 00:01:31.140
你将看到这个概述页面

00:01:31.140 --> 00:01:33.075
我建议你首先阅读一遍这个页面的内容

00:01:33.075 --> 00:01:36.998
总之 我今天要讲的是这些方面的东西

00:01:36.998 --> 00:01:41.685
这个页面都给出了相关的概况

00:01:41.685 --> 00:01:44.445
之后 当你点击这里的项目代码时

00:01:44.445 --> 00:01:48.000
它将为你打开这个嵌入式终端工作区

00:01:48.000 --> 00:01:52.215
说明文件已经在这里了

00:01:52.215 --> 00:01:54.945
那么 我们具体为你准备了什么呢？

00:01:54.945 --> 00:02:01.260
在这里 有一个这样的文件夹 上面写着 “ Andy_histogram_filter ”

00:02:01.260 --> 00:02:04.770
之后 还有一个 optimize_code 这样的文件夹 

00:02:04.770 --> 00:02:10.620
这两个文件夹的 C++ 代码 实际上完全相同

00:02:10.620 --> 00:02:13.455
如果你打开并双击它们 

00:02:13.455 --> 00:02:15.105
就会显示出所有的文件

00:02:15.105 --> 00:02:18.465
让我们回去 打开 optimize_code 文件夹

00:02:18.465 --> 00:02:20.198
这个文件夹的代码和那个完全相同

00:02:20.198 --> 00:02:23.220
我们为你提供两次代码的原因是

00:02:23.220 --> 00:02:27.135
因为 这样的话 在 andy_histogram_filter 中

00:02:27.135 --> 00:02:31.260
你拥有了所有的原始代码 然后就可以

00:02:31.260 --> 00:02:35.820
将你优化过的代码和更改版本放到这个 optimized_code 文件夹中

00:02:35.820 --> 00:02:39.660
这样 你会始终拥有原始代码的副本

00:02:39.660 --> 00:02:43.755
你做的任何更改 都会有一个副本 以便你可以回去对它们进行比较

00:02:43.755 --> 00:02:49.193
我们还提供了这个名为 hints.md 的文本文件

00:02:49.193 --> 00:02:52.970
我将不会打开它 原因如下

00:02:52.970 --> 00:02:55.100
如果你觉得自己遇到困难了 

00:02:55.100 --> 00:02:57.470
不知道该做什么 不知道该优化什么 这时这个文件才会派上用场

00:02:57.470 --> 00:03:02.525
它会给你额外的提示 告诉你如何执行该项目

00:03:02.525 --> 00:03:07.920
如何思考在每个文件中可以优化的内容

00:03:07.920 --> 00:03:10.646
现在 我们开始吧

00:03:10.646 --> 00:03:15.280
首先打开 andy_histogram_filter 文件夹

00:03:15.280 --> 00:03:18.294
然后再打开 main 文件夹

00:03:18.294 --> 00:03:19.490
我们在这里看到什么呢？

00:03:19.490 --> 00:03:23.345
看到的内容是这些标头的陈述

00:03:23.345 --> 00:03:25.690
这是它的“内容”

00:03:25.690 --> 00:03:28.852
然后 我们在这里迭代 10,000 次

00:03:28.852 --> 00:03:34.090
意思是说 每个函数将运行 10,000 次

00:03:34.090 --> 00:03:37.030
我们接着往下看

00:03:37.030 --> 00:03:38.500
我们正在制作这个矢量

00:03:38.500 --> 00:03:42.400
这个矢量代表你应该熟悉的机器人网格

00:03:42.400 --> 00:03:43.810
我们在这里说过

00:03:43.810 --> 00:03:48.085
它是 r、g、r、r、r g、r、r、g、g 等

00:03:48.085 --> 00:03:51.070
这段代码是用来干什么的呢？

00:03:51.070 --> 00:03:53.950
这里有一个重新开始的时钟

00:03:53.950 --> 00:03:56.035
它会重复 10,000 次

00:03:56.035 --> 00:03:58.315
通过 sense 函数

00:03:58.315 --> 00:04:00.685
然后输出运行它所需的时间

00:04:00.685 --> 00:04:02.970
然后 我们重置该时钟

00:04:02.970 --> 00:04:05.415
做 10,000 次模糊迭代

00:04:05.415 --> 00:04:07.275
输出所需的时间

00:04:07.275 --> 00:04:10.530
对这个规范化函数进行 10,000 次迭代

00:04:10.530 --> 00:04:13.830
花了多长时间 测试出滚动函数的结果

00:04:13.830 --> 00:04:17.730
所以你可以看到我们正在浏览每一个文件

00:04:17.730 --> 00:04:20.070
其中每个文件都代表一个函数

00:04:20.070 --> 00:04:24.735
并测试运行它们各自所需的时间

00:04:24.735 --> 00:04:27.690
而你的工作是打开这些文件 然后问问自己

00:04:27.690 --> 00:04:29.790
“ 嘿 怎么了？

00:04:29.790 --> 00:04:31.320
为什么这么慢？

00:04:31.320 --> 00:04:33.585
我们能做些什么来加快速度？”

00:04:33.585 --> 00:04:37.725
如果返回到之前的说明文件

00:04:37.725 --> 00:04:39.500
就像你以前见过的一样

00:04:39.500 --> 00:04:45.750
我们已经给出了终端代码 一切可以运行起来了

00:04:45.750 --> 00:04:50.850
如果我去改变目录 andy_histogram_filter

00:04:50.850 --> 00:04:55.380
点击进入 现在我在直方图 andy_histogram_filter 文件夹中

00:04:55.380 --> 00:04:58.935
我们只需要复制并粘贴这个 因为它太长了

00:04:58.935 --> 00:05:02.235
这将会编译代码

00:05:02.235 --> 00:05:07.455
点击进入 所以你会在这里看到它创建了

00:05:07.455 --> 00:05:14.060
a.out 这个文件 然后是最后一个命令 ./a.out 

00:05:14.060 --> 00:05:15.830
它将运行该文件

00:05:15.830 --> 00:05:17.200
然后会出现 “ Number of iterations

00:05:17.200 --> 00:05:21.910
10,000 duration milliseconds initialize beliefs 等等 ”

00:05:21.910 --> 00:05:25.930
它会告诉你运行这些函数所花的时间

00:05:25.930 --> 00:05:31.105
现在 让我们回到工作区

00:05:31.105 --> 00:05:33.430
打开 optimized_code

00:05:33.430 --> 00:05:36.760
你会在这里编写代码并更新你的文件

00:05:36.760 --> 00:05:42.775
所以如果你去打开 initialize_beliefs

00:05:42.775 --> 00:05:46.960
你会看到我们已经有了所有这些代码

00:05:46.960 --> 00:05:51.445
而且这些代码已经使直方图过滤器运行起来了

00:05:51.445 --> 00:05:54.520
实际上 你不需要做任何事情 就可以让它运行起来

00:05:54.520 --> 00:05:59.020
但你会发现有些地方你可以做一些优化

00:05:59.020 --> 00:06:01.690
我们所做的是 我们已经提出了一些想法

00:06:01.690 --> 00:06:06.250
比如 做些什么可以让它运行得更快 如优化

00:06:06.250 --> 00:06:08.590
哪些变量是必要的优化

00:06:08.590 --> 00:06:10.435
是否要在内存中为矢量预留空间？

00:06:10.435 --> 00:06:13.180
这只是举个例子 只是一种暗示

00:06:13.180 --> 00:06:15.820
暗示也许你不需要所有的变量

00:06:15.820 --> 00:06:20.565
也许还有一些额外的变量正在占用内存

00:06:20.565 --> 00:06:24.620
并且正在创建不必要的读取和写入 并让你的程序运行速度变慢

00:06:24.620 --> 00:06:27.320
正如你在课堂中看到的那样 在内存中为矢量预留空间

00:06:27.320 --> 00:06:29.820
也可以让程序运行得更快

00:06:29.820 --> 00:06:32.132
所以这是一个值得思考的问题

00:06:32.132 --> 00:06:36.635
我们在课堂上提到过一个 for 嵌套循环

00:06:36.635 --> 00:06:39.970
for 嵌套循环的效率可能非常低

00:06:39.970 --> 00:06:42.950
所以 也许有一种方法只用一个 for 循环就可以完成

00:06:42.950 --> 00:06:46.475
或以不同方式初始化事物

00:06:46.475 --> 00:06:51.975
你必须要通读代码 并找出可以改进的地方

00:06:51.975 --> 00:06:55.595
能做些什么来使运行速度加快

00:06:55.595 --> 00:06:58.725
能做些什么来让

00:06:58.725 --> 00:07:04.155
对内存的读取次数变少 并写入 CPU 要求的内存

00:07:04.155 --> 00:07:10.610
所以 实际上 在该项目中 我们会建议你一个顺序

00:07:10.610 --> 00:07:17.310
如果你回到这里的概览部分 你会看到该顺序

00:07:17.310 --> 00:07:18.480
作为一个建议

00:07:18.480 --> 00:07:21.030
该项目将按以下顺序进行

00:07:21.030 --> 00:07:24.345
我强烈建议你按照这个顺序来做

00:07:24.345 --> 00:07:27.555
从 zeros.cpp 开始 依次是 initialize_beliefs

00:07:27.555 --> 00:07:30.165
sense、 blur、 normalized、 move 函数

00:07:30.165 --> 00:07:34.770
我认为 zeros.cpp 背后的推理

00:07:34.770 --> 00:07:40.950
是最快的优化之一 因为它没有太多的代码

00:07:40.950 --> 00:07:43.463
所以这是一个很好的热身

00:07:43.463 --> 00:07:48.030
其他文件 我们已按此顺序放置 

00:07:48.030 --> 00:07:52.755
因为它是它们在 main.cpp 其中一些函数中调用的顺序

00:07:52.755 --> 00:07:55.690
现在 我要使用其他的一些函数

00:07:55.690 --> 00:07:58.350
所以 如你所说

00:07:58.350 --> 00:08:01.020
首先从 zeros.cpp 开始

00:08:01.020 --> 00:08:04.410
我觉得 blur.cpp 要使用 zeros.cpp

00:08:04.410 --> 00:08:06.450
所以 如果你已经在这里优化

00:08:06.450 --> 00:08:09.330
你的 blur.cpp 应该已经运行得更快了

00:08:09.330 --> 00:08:13.160
接下来 让我们回到项目代码片刻

00:08:13.160 --> 00:08:18.460
你解决所有这些问题的主要流程将会像下面这样

00:08:18.460 --> 00:08:23.599
所以 就像我说的那样 打开 zeros.cpp

00:08:23.599 --> 00:08:28.950
我们的这个 zeros.cpp 将会

00:08:28.950 --> 00:08:35.515
初始化一个只包含很多零的二维矢量

00:08:35.515 --> 00:08:39.900
我们在这里说过 优化矢量中的预留空间 newGrid

00:08:39.900 --> 00:08:42.120
优化 for 嵌套循环是不需要的

00:08:42.120 --> 00:08:44.940
因为矩阵中的每一行都完全相同

00:08:44.940 --> 00:08:48.390
你可能还会想到其他优化

00:08:48.390 --> 00:08:51.880
那些优化可能会让你的代码比我们提供的解决方案更快

00:08:51.880 --> 00:08:55.965
所以说 这并不是全部和最终的优化版本

00:08:55.965 --> 00:08:59.895
这些只是确保你可以使代码运行更快的方法

00:08:59.895 --> 00:09:06.840
所以 我要在这里进入终端并更改我的目录

00:09:06.840 --> 00:09:09.750
我在这里完成的是我改变了目录

00:09:09.750 --> 00:09:12.780
.. 意味着后退一步

00:09:12.780 --> 00:09:14.340
它将会把我带回工作区

00:09:14.340 --> 00:09:16.110
然后开始优化代码

00:09:16.110 --> 00:09:18.440
这就是这行代码的含义

00:09:18.440 --> 00:09:22.770
所以现在我在优化代码文件夹中

00:09:22.770 --> 00:09:24.788
你可以在左边这里看到

00:09:24.788 --> 00:09:27.495
我已经把 zeros.cpp 文件夹打开了

00:09:27.495 --> 00:09:32.265
将要进行代码编译

00:09:32.265 --> 00:09:35.821
让我们在说明中查找这个命令

00:09:35.821 --> 00:09:39.716
编译它 然后使用 a.out 来运行它

00:09:39.716 --> 00:09:43.670
这就是所给出的自然状态下的代码

00:09:43.670 --> 00:09:49.720
现在 zeros.cpp 不会显示在这里 因为很多函数都在使用它

00:09:49.720 --> 00:09:51.935
所以它没有单独测试

00:09:51.935 --> 00:09:54.170
通过让这个运行得更快

00:09:54.170 --> 00:09:56.060
我们也会让这个运行得更快

00:09:56.060 --> 00:09:57.980
那么 这里是什么呢？

00:09:57.980 --> 00:10:00.710
为矢量保留的优化内存空间

00:10:00.710 --> 00:10:06.650
所以 我们的输入是这样的高度和宽度

00:10:06.650 --> 00:10:09.200
这里是 newGrid 和 newRow 

00:10:09.200 --> 00:10:12.772
所以我只是在这里说 

00:10:12.772 --> 00:10:14.380
让我们从 newRow 或 newGrid 开始

00:10:14.380 --> 00:10:18.695
这里是 newGrid.reserve（height）

00:10:18.695 --> 00:10:22.205
所以我们说 newGrid.reserve 将会是 

00:10:22.205 --> 00:10:26.743
一个矢量 它需要有高度的长度

00:10:26.743 --> 00:10:33.695
然后是 newRow.reserve（width）

00:10:33.695 --> 00:10:35.990
所以 如果你还记得本课前面的内容

00:10:35.990 --> 00:10:39.320
这可能会让你的代码运行更快的原因在于

00:10:39.320 --> 00:10:43.775
当你用 C++ 创建一个矢量时

00:10:43.775 --> 00:10:46.490
它保留了一定的空间

00:10:46.490 --> 00:10:51.965
但该程序并不能事先知道你将最终实际使用多少空间

00:10:51.965 --> 00:10:56.270
所以 如果你经过那个 C++ 的预留空间量

00:10:56.270 --> 00:10:59.090
编译器会自动为你保留

00:10:59.090 --> 00:11:02.690
然后编译器需要采用整个矢量

00:11:02.690 --> 00:11:08.395
或寻找一个新的可用内存部分 并将整个矢量重新复制过来

00:11:08.395 --> 00:11:09.830
这样确实效率很低

00:11:09.830 --> 00:11:12.560
但是 如果你事先知道矢量的长度

00:11:12.560 --> 00:11:15.630
并且保留了需要的内存量

00:11:15.630 --> 00:11:20.820
那么 你的编译器就不需要做整个复制步骤

00:11:20.820 --> 00:11:23.025
那么我们要做什么呢？我们仅需做这个更改就可以了

00:11:23.025 --> 00:11:26.828
而且我认为这样会使代码运行更快

00:11:26.828 --> 00:11:30.255
但我真的知道吗？我无法确定

00:11:30.255 --> 00:11:31.740
我需要测试它

00:11:31.740 --> 00:11:34.148
测试是优化的重要组成部分

00:11:34.148 --> 00:11:38.565
你有想法 而且有直觉和感觉

00:11:38.565 --> 00:11:40.480
但直觉和感觉并不总是正确的

00:11:40.480 --> 00:11:42.150
所以你需要测试一下

00:11:42.150 --> 00:11:43.988
所以现在 我回到这里

00:11:43.988 --> 00:11:51.940
然后再次使用这个命令来编译 code./a.out

00:11:51.940 --> 00:11:56.130
现在让我们来比较一下我们之前和现在的情况

00:11:56.130 --> 00:11:59.490
这整个部分就是我们在更改之前所做的

00:11:59.490 --> 00:12:03.330
而这整个部分就是我们在更改之后的版本

00:12:03.330 --> 00:12:09.135
看起来 initialize_beliefs 的速度稍微快一些

00:12:09.135 --> 00:12:11.550
但并不是非常快 所以 让我们看一看

00:12:11.550 --> 00:12:16.770
initialize_beliefs 是否使用了 zeros.cpp？

00:12:16.770 --> 00:12:19.560
看起来没有使用

00:12:19.560 --> 00:12:24.540
所以 这种差异可能只是因为一些随机性

00:12:24.540 --> 00:12:27.570
每次你运行你的代码都会有一些不同

00:12:27.570 --> 00:12:31.170
但看起来这是正常化的

00:12:31.170 --> 00:12:37.530
这个滚动函数在时间上有了较大的变化

00:12:37.530 --> 00:12:40.605
所以 我要打开 move 文件

00:12:40.605 --> 00:12:43.092
看这里 zeros.h

00:12:43.092 --> 00:12:45.600
这意味着这是在使用零函数

00:12:45.600 --> 00:12:53.297
在我们进入到 zeros.cpp 的时候 做了那个非常小的更改

00:12:53.297 --> 00:12:58.555
并且我们预先在内存中预留了空间 

00:12:58.555 --> 00:13:04.185
似乎就是它让我们有很多时间去更改我们的代码

00:13:04.185 --> 00:13:06.600
然后让我们再次运行代码

00:13:06.600 --> 00:13:10.440
在滚动函数 中 它将持续 40 毫秒左右

00:13:10.440 --> 00:13:14.228
所以 这看起来很有帮助

00:13:14.228 --> 00:13:15.480
很厉害 是不是？我的意思是

00:13:15.480 --> 00:13:21.150
你只需预先在内存中预留空间 即可缩短 20 毫秒

00:13:21.150 --> 00:13:26.385
所以 当 move.cpp 函数结束调用你的零函数时

00:13:26.385 --> 00:13:29.295
这部分代码已经运行得更快了

00:13:29.295 --> 00:13:34.140
我不想做太多透露 因为这是一个非常有趣的项目

00:13:34.140 --> 00:13:36.690
所以我只想去思考一下 然后去动手尝试

00:13:36.690 --> 00:13:39.455
看看什么能让程序变得更快

00:13:39.455 --> 00:13:47.285
如果你返回工作区 你会看到 我们还在 hints.md 文件中为你提供了提示信息

00:13:47.285 --> 00:13:49.262
但这基本上就是整个项目

00:13:49.262 --> 00:13:51.920
你要做的是看一看每个文件

00:13:51.920 --> 00:13:57.628
思考一下 怎样做可以让程序运行得更快

00:13:57.628 --> 00:14:00.260
做了每次更改之后 你需要进行测试 测试 再测试

00:14:00.260 --> 00:14:05.323
因为你可能认为有些事情会让它变得更快

00:14:05.323 --> 00:14:08.405
但这可能是在过去的情况 

00:14:08.405 --> 00:14:10.355
但是每个代码都是不同的

00:14:10.355 --> 00:14:12.065
每台机器也都不一样

00:14:12.065 --> 00:14:15.335
所以测试真的非常重要

00:14:15.335 --> 00:14:19.678
如果你没有测试

00:14:19.678 --> 00:14:22.895
你最终可能会让你的代码更慢

00:14:22.895 --> 00:14:26.750
然后进行调整 才能变得更快

00:14:26.750 --> 00:14:29.510
而你并没有意识到你的代码并不总是那样高效

00:14:29.510 --> 00:14:31.115
所以 需要不断进行测试

00:14:31.115 --> 00:14:37.308
我只想在这里提到的另一件事是 blur、 initialize

00:14:37.308 --> 00:14:41.210
move、 normalize、 sense 与 zeros 

00:14:41.210 --> 00:14:44.990
所有这些文件都有你可以优化的地方

00:14:44.990 --> 00:14:47.456
但是 print.cpp 和 main.cpp 这两个

00:14:47.456 --> 00:14:49.765
你不需要进行更改

00:14:49.765 --> 00:14:52.530
Main.cpp 只是运行你的代码

00:14:52.530 --> 00:14:55.875
和我之前的解释那样 输出所需的时间

00:14:55.875 --> 00:15:01.920
至于 Print.cpp 如果你想用它进行调试 它只是包含在这里

00:15:01.920 --> 00:15:04.103
它在这里有两个函数

00:15:04.103 --> 00:15:08.768
一个是 print_vector_float 另一个是 print_vector_char

00:15:08.768 --> 00:15:10.380
它们之所以是两个不同的函数 原因在于

00:15:10.380 --> 00:15:13.950
说不定你需要输出你的 2D 矢量

00:15:13.950 --> 00:15:18.120
我们为你编写了代码 这样你就不必再重复一遍

00:15:18.120 --> 00:15:21.120
但你有责任输入正确的标头

00:15:21.120 --> 00:15:23.865
并把它们放在正确的位置

00:15:23.865 --> 00:15:28.965
此外 这些文件中的每一个文件都包含哪些地方可以优化的想法

00:15:28.965 --> 00:15:31.530
你也可以想出其他的方法

00:15:31.530 --> 00:15:36.810
如果返回到工作区文件夹 

00:15:36.810 --> 00:15:38.590
实际上就是回到顶端

00:15:38.590 --> 00:15:42.960
你会看到 我们还为你提供了这个页面 作为项目解决方案

00:15:42.960 --> 00:15:46.635
在下一节课中 我们将为代码优化项目提供解决方案

00:15:46.635 --> 00:15:48.480
每个文件都包含注释内容

00:15:48.480 --> 00:15:51.105
标注出了已做出更改的地方 这些更改可以使代码运行得更快

00:15:51.105 --> 00:15:53.505
所以 这也取决于你

00:15:53.505 --> 00:15:57.060
我们建议你先不要去看提供的解决方案 而是自己动手去做所有事情 

00:15:57.060 --> 00:16:01.200
直到你对你的代码运行速度感到满意

00:16:01.200 --> 00:16:04.688
但我们已提供了一个解决方案

00:16:04.688 --> 00:16:07.316
我们的解决方案

00:16:07.316 --> 00:16:09.045
不一定是最快的

00:16:09.045 --> 00:16:15.795
但是它显示了根据本课所教授的内容 以及我们能够想出的优化方法

00:16:15.795 --> 00:16:21.440
我想再次提到的另外一件事是 C++ Slack 板块

00:16:21.440 --> 00:16:25.101
你完成了这个项目后

00:16:25.101 --> 00:16:29.070
将结果发布到那里 并把你的结果与其他学生进行比较

00:16:29.070 --> 00:16:34.335
关于如何才能运行得更快 你可能会获得新的建议

00:16:34.335 --> 00:16:36.990
所以 希望在完成这个项目后

00:16:36.990 --> 00:16:41.385
你能真正理解

00:16:41.385 --> 00:16:46.920
如何在 andy_histogram_filter 中

00:16:46.920 --> 00:16:50.625
处理这种低效率的代码 

00:16:50.625 --> 00:16:54.930
如何去优化代码 并做一些小的更改

00:16:54.930 --> 00:16:58.770
根据你对 CPU 的了解以及它如何使用 RAM

00:16:58.770 --> 00:17:04.110
让你的代码运行得更快

