WEBVTT
Kind: captions
Language: ja

00:00:00.020 --> 00:00:04.230
これが私の提案するお気に入りの順番です
まずはスタブとしてdaysInMonthを書いていきます

00:00:04.230 --> 00:00:08.460
これはyearとmonthを使って常に30を返します
もちろん誤りです

00:00:08.460 --> 00:00:12.660
そしてそのスタブを使用するために
nextDayを修正します

00:00:12.660 --> 00:00:16.300
そこですぐにそれをテストします
この時点では何も行いません

00:00:16.300 --> 00:00:19.550
実際は状況に誤りがない場合
以前得たものから出力を変更しますが

00:00:19.550 --> 00:00:22.800
今はコードをいくらか再編成します

00:00:22.800 --> 00:00:26.760
daysInMonthを改良しなければなりません
これで正確な答えを得られます

00:00:26.760 --> 00:00:31.670
次に正確になるようにdaysInMonthを修正します
ただしうるう年は除きます

00:00:31.670 --> 00:00:35.020
できる限り うるう年はあと回しにします
なぜなら面倒だからです

00:00:35.020 --> 00:00:38.530
しかし時折現れる複雑さは他にもあります

00:00:38.530 --> 00:00:41.910
そしてかなり正確な答えに近づくことができます
あと回しにしたものがありますが

00:00:41.910 --> 00:00:45.170
コードのすべての構造が完成し
すべて整っていることが確認できます

00:00:45.170 --> 00:00:48.880
だからあと回しにします
テストをもう一度行うとよいでしょう

00:00:48.880 --> 00:00:52.850
5つのステップでもう一度テストを行います
daysInMonthを使用して

00:00:52.850 --> 00:00:57.640
テストを行うと完璧になるでしょう
nextDayでテストする方が簡単だと思います

00:00:57.640 --> 00:01:02.230
ステップ3で行った同じテストを
ただ実行し続けるだけだからです

00:01:02.230 --> 00:01:06.540
これでうるう年をこれ以上あと回しには
できない所までやってきました

00:01:06.540 --> 00:01:10.420
次にうるう年に取り掛かります
うるう年のヘルパー関数を書きます

00:01:10.420 --> 00:01:15.090
これがステップ6です　それを別々にテストします

00:01:15.090 --> 00:01:18.530
ここで意見が分かれるもう1つのステップです
daysInMonthまたはnextDayを使います

00:01:18.530 --> 00:01:22.370
この場合はうるう年です
これはとても特別なケースです

00:01:22.370 --> 00:01:26.100
別々にテストを行う方が理にかなっています

00:01:26.100 --> 00:01:30.190
テストが終了したら完全に正確な解決策が
得られるはずです　別々にテストします

00:01:30.190 --> 00:01:33.740
この時点で残りの私のコードには
とても自信があります

00:01:33.740 --> 00:01:37.450
ステップKに進みすべてのケースを実行します

00:01:37.450 --> 00:01:41.720
これが私が提案する順序ですが
他にも様々な順序があります

00:01:41.720 --> 00:01:44.570
うるう年の処理は最初に移動させてもよいでしょう

00:01:44.570 --> 00:01:48.040
うるう年が好きならあと回しにする必要はありません
個別に先に行うと簡単です

00:01:48.040 --> 00:01:51.950
もう1つはnextDayをテストに使用するのではなく

00:01:51.950 --> 00:01:55.170
daysInMonthでテストしてもよいでしょう
とても合理的です

00:01:55.170 --> 00:01:58.390
この問題の正解が複数あります

00:01:58.390 --> 00:02:02.340
すべての正解がそろっているはずのプロパティには
個別にテストができるコードを少し書きます

00:02:02.340 --> 00:02:06.020
たくさんのコードを書く必要はありませんし
テストはできません

00:02:06.020 --> 00:02:09.509
開発者として学ぶ最も重要なことは

00:02:09.509 --> 00:02:12.930
組み立てるコードをまとめるために
コードを構造化する方法を考えることです

00:02:12.930 --> 00:02:16.700
そうすることで意味のあるテストを行えます

00:02:16.700 --> 00:02:20.300
それに必要な解決策に徐々に近づいているコードが
確認できます

00:02:20.300 --> 00:02:24.130
プログラマとしての自信がさらに増してきたところで
これらのステップを飛ばすことができます

00:02:24.130 --> 00:02:27.540
なぜこの問題を出したのかと言うと

00:02:27.540 --> 00:02:31.110
私がこの問題を自分で解こうとした時
解決策にバグがあったのです

00:02:31.110 --> 00:02:35.270
ステップを十分注意して行わなかったからです
すべてのテストケースを実行し失敗しました

00:02:35.270 --> 00:02:39.440
このパターンに従っていた場合よりも
デバッグに長い時間を要しました

00:02:39.440 --> 00:02:43.470
解決策を考え出す場合 解決策の一部として

00:02:43.470 --> 00:02:47.550
すべてのテストを実行するためのコードを
書くことをおすすめします

00:02:47.550 --> 00:02:51.930
最終的にステップKに達したら
すべてのテストケースを実行してください

00:02:51.930 --> 00:02:56.210
初回で魔法のようにすべてが正確に機能するでしょう

00:02:56.210 --> 00:02:57.910
でも魔法ではありません

00:02:57.950 --> 00:03:01.450
それが系統的に注意深く物事を組み立てた結果です

