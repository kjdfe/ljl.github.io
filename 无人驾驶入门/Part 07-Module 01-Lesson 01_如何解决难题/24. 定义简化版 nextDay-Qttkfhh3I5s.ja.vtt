WEBVTT
Kind: captions
Language: ja

00:00:00.200 --> 00:00:04.080
これがnextDayを実装する私の解決策です
docstringから始めています

00:00:04.080 --> 00:00:08.080
こうすると ほとんどのPythonシステムで
コメントとして扱われます

00:00:08.080 --> 00:00:11.990
この仮定が正確ではないことを
知らせるため警告を入れました

00:00:11.990 --> 00:00:15.470
スケジュールの使用には向いていないので
仮に黙示録としておきましょう

00:00:15.470 --> 00:00:19.120
ですが今のテストには適しています
論理はとても簡単です

00:00:19.120 --> 00:00:23.020
もし日数が30日より少なかった場合
すべての月が30日であると仮定しているので

00:00:23.020 --> 00:00:27.010
その日に1を加えます
year、month、dayの3つをタプルとして返します

00:00:27.010 --> 00:00:30.670
そうでない場合 次の月にする必要があります
月を進めて日付を1日に戻します

00:00:30.670 --> 00:00:35.920
12月の場合 次の年にして日付を1月1日に戻します

00:00:35.920 --> 00:00:40.450
大きな問題と同様に複数のテストケースを
考えることから始める必要があります

00:00:40.450 --> 00:00:44.660
予測どおりに作用するのかを確認します

00:00:44.660 --> 00:00:48.890
例を挙げます
与えられたPythonシェルを使うと次の利点があります

00:00:48.890 --> 00:00:52.790
nextDayを使用すると
ここでdocstringが確認できるのです

00:00:52.790 --> 00:00:56.550
通常 記述的なdocstringがここに必要です

00:00:56.550 --> 00:01:00.520
警告はとても有益です
そしてmonth、day、yearのサンプルを与えます

00:01:00.520 --> 00:01:04.610
すると正しい結果が取得できます
ただし結果に注意が必要な場合もあります

00:01:04.610 --> 00:01:08.760
例えば1月30日は次の日が1月31日のはずです

00:01:08.760 --> 00:01:12.950
各月を30日と仮定しているので2月2日になるのです

00:01:12.950 --> 00:01:16.940
ではもっと難しい問題に挑戦してみましょう
例えば12月31日です

00:01:16.940 --> 00:01:21.100
この仮定では年が変わると12月31日
または12月30日なります

00:01:21.100 --> 00:01:24.890
2013年1月1日になりました

