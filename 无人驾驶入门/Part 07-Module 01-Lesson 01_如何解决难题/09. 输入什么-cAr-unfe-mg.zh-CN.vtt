WEBVTT
Kind: captions
Language: zh-CN

00:00:00.025 --> 00:00:03.440
对于任何问题 我们首先需要回答的是 输入是什么？

00:00:03.440 --> 00:00:07.334
对于这个问题 他们相当清楚地声明 给出你的生日和

00:00:07.334 --> 00:00:10.502
当前日期 好 这是该问题的输入 不过我们真正想要

00:00:10.502 --> 00:00:13.685
计算的输入是什么？真的只是单纯计算“我的生日”和

00:00:13.685 --> 00:00:17.305
“今天的日期”吗？如果这就是我们想要的话 一次计算就可以

00:00:17.305 --> 00:00:20.508
解出 我们不必去写一个过程 所以我想

00:00:20.508 --> 00:00:24.729
这里指的是更普遍的含义 因此 输入实际上是两个

00:00:24.729 --> 00:00:27.803
日期 这为我们提供了输入的类型 提供了所有可能的

00:00:27.803 --> 00:00:31.180
输入集合 我们需要一些更谨慎的思考去确认输入是否有效

00:00:31.180 --> 00:00:34.283
那么 问题陈述这里给我们一个很好的线索 它说

00:00:34.283 --> 00:00:38.561
假设出生日期和当前日期都是正确的日期 并且不存在时间旅行

00:00:38.561 --> 00:00:41.988
如果我们谈论的是出生日期和当前日期 这很可能是个有效的假设

00:00:41.988 --> 00:00:46.499
如果我们比较任何两个日期 这意味着第二个日期应该

00:00:46.499 --> 00:00:51.152
在第一个之后 这样的假设使程序员的生活更轻松

00:00:51.152 --> 00:00:55.660
意味着可以更容易地写我们的代码 因为它只需计算

00:00:55.660 --> 00:00:59.768
更少的输入集合 我喜欢 Mattias 这里没有时间旅行的陈述

00:00:59.768 --> 00:01:04.058
不过对于程序规范 我们可能想要更精确一点

00:01:04.058 --> 00:01:08.200
只需简单陈述 第二个日期必须不在第一个日期之前 如果我们是

00:01:08.200 --> 00:01:11.244
有着良好意识的程序员 我们应当检查这是否是真的

00:01:11.244 --> 00:01:16.458
这是一条假设 它要求我们代码的使用者满足它 因为我们已经说了

00:01:16.458 --> 00:01:20.610
这是一个要求 要使用我们的解法 你必须确保第二个日期

00:01:20.610 --> 00:01:24.020
不在第一个日期之前 但是我们如果想更巧妙的话 我们应当以

00:01:24.020 --> 00:01:27.485
更严谨的方式编程 因为有时人们可能会犯错

00:01:27.485 --> 00:01:30.944
当然也包括我们自己 所以我们实际上将会在代码中检查

00:01:30.944 --> 00:01:34.835
另一个我们想要的假设可能是日期的范围

00:01:34.835 --> 00:01:39.105
历法是很复杂的 它们随着历史演变

00:01:39.105 --> 00:01:44.110
我们将要求日期是有效的公历日期

00:01:44.110 --> 00:01:48.142
公历从 1582 年 10 月开始 我们的代码对于在这个范围之外的日期也许会

00:01:48.142 --> 00:01:51.726
有效 但很可能不会得到正确的答案

00:01:51.726 --> 00:01:53.553
因为当历法改变时 日期的含义也改变了

