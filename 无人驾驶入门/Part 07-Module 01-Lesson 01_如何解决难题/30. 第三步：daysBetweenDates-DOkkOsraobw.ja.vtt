WEBVTT
Kind: captions
Language: ja

00:00:00.000 --> 00:00:03.680
これでヘルパー関数ができました
dateBetweenDatesを改良すると簡単になります

00:00:03.680 --> 00:00:07.620
1つ目の日付が2つ目の日付の前にあるかチェックする
whileループ条件があります

00:00:07.620 --> 00:00:12.930
そしてnextDayでyear1とmonth1、day1の値を
更新します

00:00:12.930 --> 00:00:16.059
日数に1を加えます　例を試してみましょう

00:00:16.110 --> 00:00:21.360
前に手動で行い155を得たものです
これは完全に正確ではありませんがほぼ合っています

00:00:21.360 --> 00:00:25.020
手動でこれを試した時は156になりました

00:00:25.020 --> 00:00:31.460
nextDayでは各月が30日であると仮定しています
完全な正解を得られなくとも驚くことではありません

00:00:31.480 --> 00:00:33.020
別の例を試してみましょう

00:00:33.020 --> 00:00:36.750
これは私たちの解決策が十分な速度であると分かる
よい要所確認になるでしょう

00:00:36.750 --> 00:00:42.020
ここに100年に相当する3万6，000を取得しました
正しいようです　正確な1年の長さではなく

00:00:42.110 --> 00:00:49.080
30日の12ヵ月で1年の長さは360日になります
もう1回他の例を試してみましょう

00:00:49.080 --> 00:00:52.910
これを実行する前に何が起きるか当ててみてください
答えはゼロです

00:00:52.910 --> 00:00:56.510
これが完全に正しいわけではありません
これらは同じ日ではありません

00:00:56.510 --> 00:01:00.660
1つ目の日付は2つ目の日付の後にはないと
仮定したことをdaysBetweenDatesが行う文では

00:01:00.660 --> 00:01:04.860
有効な解答です　この場合1つ目の日付が
2つ目の日付のあとにありますが

00:01:04.860 --> 00:01:07.800
完全に条件を満たした解答ではありません

00:01:07.840 --> 00:01:12.060
答えをゼロにしたくありません　1つ目の日付が
2つ目の日付のあとにあると指定を変更できます

00:01:12.060 --> 00:01:16.420
そしてゼロを返しますが
これは少し変わったものの見方です

00:01:16.460 --> 00:01:21.170
これのネガティブな結果を出すことが
意味があるかどうかです

00:01:21.260 --> 00:01:23.060
これはコードをさらに複雑にします

00:01:23.060 --> 00:01:27.120
このレッスン後に練習してください

00:01:27.120 --> 00:01:30.840
ここではプログラムのエラーを
検証する記述を書きましょう

00:01:30.840 --> 00:01:35.640
機能を左右する仮定が入力で満たされていない場合

00:01:35.640 --> 00:01:38.840
他の予想外の作動や
謎めいた結果を得たり継続するよりも

00:01:38.840 --> 00:01:42.940
アサーションでエラーを発生させるほうが
はるかに役に立つのです

00:01:42.940 --> 00:01:44.630
では小テストを自分で解いてみてください

