WEBVTT
Kind: captions
Language: zh-CN

00:00:00.210 --> 00:00:04.236
这是我要推荐的我最喜欢的顺序 首先我们先写一个

00:00:04.236 --> 00:00:08.460
daysInMonth 的雏形 它将输入一个年份和月份 并总是返回 30

00:00:08.460 --> 00:00:12.663
这当然不正确 之后我们将修改 nextDay 函数

00:00:12.663 --> 00:00:16.300
来使用这个雏形 然后立刻对它进行测试

00:00:16.300 --> 00:00:19.550
截止到此时 我们还没有真正改变之前获得的输出

00:00:19.550 --> 00:00:22.800
如果测试是正确的话 但是我们现在正在重新构建代码

00:00:22.800 --> 00:00:26.760
我们所要做的就是改进 daysInMonth 函数 然后我们将会得到正确的答案

00:00:26.760 --> 00:00:31.674
下一件要做的 是将 daysInMonth 在不考虑闰年的情况下修改正确

00:00:31.674 --> 00:00:35.020
我会把考虑闰年尽量推迟 因为闰年真的很烦

00:00:35.020 --> 00:00:38.530
但是这种复杂性也只是偶尔出现

00:00:38.530 --> 00:00:41.910
我们可以先得到一个非常接近正确的答案 并且知道

00:00:41.910 --> 00:00:45.174
我们已经获得了所有的代码结构 一切都在合适的位置

00:00:45.174 --> 00:00:48.882
所以我将推迟考虑闰年 然后我认为再次测试是个好主意

00:00:48.882 --> 00:00:52.858
因此我们将在第五步再次测试 在这里

00:00:52.858 --> 00:00:57.648
用 daysInMonth 来测试当然是完全没有问题的 但是我认为一个更简单的方法是

00:00:57.648 --> 00:01:02.236
用 nextDay 因为我们只需要再运行一次 和步骤3一样的测试就可以了

00:01:02.236 --> 00:01:06.541
现在我们就到了需要考虑闰年的时候了

00:01:06.541 --> 00:01:10.427
所以接下来要解决闰年的问题 我将先写一个

00:01:10.427 --> 00:01:15.097
辅助函数 isLeapYear 这是步骤6 之后我将对它进行单独测试

00:01:15.098 --> 00:01:18.532
这是另一个你可能会有异议的步骤 会想也可以用

00:01:18.532 --> 00:01:22.375
daysInMonth 或者 nextDay 来测试 但是 isLeapYear 有点特别

00:01:22.375 --> 00:01:26.108
把它拿来单独测试会更加有意义 好的 完成这个之后

00:01:26.108 --> 00:01:30.195
就有了一个完整的解决方案了 可以再分开测试它一下

00:01:30.195 --> 00:01:33.749
但是我现在对我剩下的代码很有信心 我将直接跳到

00:01:33.749 --> 00:01:37.450
步骤 K 来运行所有的测试用例 这就是我推荐的顺序了

00:01:37.450 --> 00:01:41.720
但是当然还有很多其他顺序也是对的 其中一个就是

00:01:41.720 --> 00:01:44.570
你可以把闰年的程序放到最开始去

00:01:44.570 --> 00:01:48.048
如果你喜欢闰年 也不想把它推迟到后面再做的话

00:01:48.048 --> 00:01:51.956
那就可以先单独把它弄完 另一件可能会发生的事是

00:01:51.956 --> 00:01:55.176
用了 daysInMonth 来测试 而不是 nextDay 这也是完全没问题的

00:01:55.176 --> 00:01:58.395
所以对于这个问题 这里有很多正确的答案

00:01:58.395 --> 00:02:02.348
这些所有正确答案共同的特点是 不停地写一点点代码

00:02:02.348 --> 00:02:06.022
然后再对其进行独立测试 而不是写一大堆代码

00:02:06.022 --> 00:02:09.514
而不能对它进行测试 在开发者要学习的事情中

00:02:09.514 --> 00:02:12.938
最重要的一件是 思考结构化代码的方法

00:02:12.938 --> 00:02:16.708
去组织你构建代码的方法 这样你就能够在写的时候 进行有意义的测试

00:02:16.708 --> 00:02:20.304
并且看着代码一步步越来越接近你需要的正确答案

00:02:20.304 --> 00:02:24.132
当你对作为一个程序员更加有自信的时候 你可能会跳过一些步骤

00:02:24.132 --> 00:02:27.540
但是我问这个问题的部分动机是

00:02:27.540 --> 00:02:31.115
当我自己做这个问题的时候 我的解答出现了一个 bug 这是因为

00:02:31.115 --> 00:02:35.278
我没有足够仔细地按照步骤来做 当我试着运行所有测试时

00:02:35.278 --> 00:02:39.440
它们都失败了 比起按照步骤做 调试多花了很多时间

00:02:39.440 --> 00:02:43.470
当你在解答时 我要鼓励你去做的是

00:02:43.470 --> 00:02:47.550
作为你解答的一部分 写代码来运行所有测试 之后我期盼的是

00:02:47.550 --> 00:02:51.937
如果你进行了所有步骤 也都测试完了 当你最后到达步骤 K 时

00:02:51.937 --> 00:02:56.215
把程序在所有测试用例上运行时 它将神奇般地一次就运行正确了

00:02:56.215 --> 00:03:00.014
当然这并不是什么魔法 这只是系统地以及小心地

00:03:00.014 --> 00:03:01.453
解决问题的自然结果

