WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.280
我们看看高通滤波器到底是如何工作的

00:00:04.280 --> 00:00:08.975
我之前提过 高通滤波器可以探测小范围内色饱和度的剧烈变化

00:00:08.974 --> 00:00:12.800
色饱和度团在灰阶图像中表现最好

00:00:12.800 --> 00:00:16.530
例如 如果我们把这幅汽车的图像放入一个高通滤波器

00:00:16.530 --> 00:00:18.995
我们期待汽车的边缘会被探测到

00:00:18.995 --> 00:00:21.464
比如汽车顶部的边缘

00:00:21.464 --> 00:00:26.120
在这个点上 图像从非常亮的区域进入了神色背景

00:00:26.120 --> 00:00:28.445
还有很多类似的小区域

00:00:28.445 --> 00:00:30.984
从较亮的变为暗色区域 或是反向变化的

00:00:30.984 --> 00:00:33.769
经过滤波后 完整的图像应该是这样的

00:00:33.770 --> 00:00:37.460
汽车的边缘和道路上的线用白色标出

00:00:37.460 --> 00:00:39.799
你还可以看到原始图像中

00:00:39.799 --> 00:00:42.329
色饱和度没有或几乎没有变化的地方

00:00:42.329 --> 00:00:44.795
比如 这些大片黑色和明亮区域

00:00:44.795 --> 00:00:49.145
高通滤波器会屏蔽这些区域 把像素变黑

00:00:49.145 --> 00:00:52.460
我使用的滤波器形式上是矩阵

00:00:52.460 --> 00:00:54.590
它们通常叫做卷积核

00:00:54.590 --> 00:00:57.425
它们是由数字组成的网格 可以修改图像

00:00:57.424 --> 00:01:01.019
下面是执行边缘探测的一个高通滤波器的例子

00:01:01.020 --> 00:01:05.750
它是一个 3 乘 3 的核 所有元素相加等于 0

00:01:05.750 --> 00:01:07.525
这一点对边缘探测很重要

00:01:07.525 --> 00:01:09.180
所有元素总和等于 0

00:01:09.180 --> 00:01:14.025
因为这个滤波器计算的是相邻像素之间的差别或变化

00:01:14.025 --> 00:01:18.080
差别的计算方法是 像素值之间相减

00:01:18.079 --> 00:01:22.759
在本例中 我们减去围绕在中心像素的其他像素值

00:01:22.760 --> 00:01:25.530
如果这些核的值加起来不等于 0

00:01:25.530 --> 00:01:27.599
则说明计算出的结果

00:01:27.599 --> 00:01:29.964
可能是正加权或负加权的

00:01:29.965 --> 00:01:34.859
这可能导致整个滤波后的图像偏亮或偏暗

00:01:34.859 --> 00:01:37.409
要应用这个滤波器 在输入图像上

00:01:37.409 --> 00:01:38.534
我把它叫做 F(x,y)

00:01:38.534 --> 00:01:40.875
这是一个 x 和 y 空间的函数

00:01:40.875 --> 00:01:42.569
对这个函数使用这个核进行卷积

00:01:42.569 --> 00:01:46.274
这个核叫做 K 这个过程叫做核卷积

00:01:46.275 --> 00:01:48.930
卷积用星号表示

00:01:48.930 --> 00:01:51.105
不要和乘法搞混

00:01:51.105 --> 00:01:55.605
核卷积是计算机视觉应用里的重要运算

00:01:55.605 --> 00:01:59.005
它是卷积神经网络的基础

00:01:59.004 --> 00:02:00.284
它需要有一个核

00:02:00.284 --> 00:02:01.890
也就是由数字组成的小网格

00:02:01.890 --> 00:02:04.545
然后把它逐个像素地传递到一幅图像上

00:02:04.545 --> 00:02:09.659
从而根据网格中的数字 创建另一个探测出边缘的输出图像

00:02:09.659 --> 00:02:12.622
我们会看到 变更核中的数字后

00:02:12.622 --> 00:02:17.129
我们能获得很多效果 从边缘探测到模糊化

00:02:17.129 --> 00:02:21.164
下面 我们使用这个 3 乘 3 的边缘探测器 来解一个数学例子

00:02:21.164 --> 00:02:23.400
为了更清楚地看到像素级的运算

00:02:23.400 --> 00:02:25.469
我放大图像 就在

00:02:25.469 --> 00:02:28.465
汽车边缘这里 查看灰阶的像素值

00:02:28.465 --> 00:02:31.500
首先 对于这个灰阶图像中的每一个像素

00:02:31.500 --> 00:02:36.094
我们都在上面应用一个核 让这个像素和核的中心对齐

00:02:36.094 --> 00:02:39.344
这个像素作为一个例子

00:02:39.344 --> 00:02:43.935
然后 我们查看围绕这个像素的 3 乘 3 的像素网格

00:02:43.935 --> 00:02:46.140
然后我们取核中的数字

00:02:46.139 --> 00:02:49.649
把它们和对应的像素分对相乘

00:02:49.650 --> 00:02:53.120
这样 左上角的这个像素值 150

00:02:53.120 --> 00:02:56.438
乘以核的左上角数字 0

00:02:56.437 --> 00:03:00.627
旁边 我们把数字 45 乘以负 1

00:03:00.627 --> 00:03:02.984
接下来 25 乘以 0

00:03:02.985 --> 00:03:05.085
然后我们移到下一行

00:03:05.085 --> 00:03:09.420
对所有 9 个像素和的值对同样操作

00:03:09.419 --> 00:03:14.459
注意 中心像素的值 200 会乘以 4

00:03:14.460 --> 00:03:19.064
最后 这些值求和 得到了一个新的像素值 175

00:03:19.064 --> 00:03:22.844
这个值很高 说明检测到了一个很强的边缘

00:03:22.844 --> 00:03:26.729
我们查看图像中的这个 3 乘 3 区域就可以看到

00:03:26.729 --> 00:03:30.299
它从非常亮变为了顶部的深色

00:03:30.300 --> 00:03:34.380
核中的因子经常被叫做权重 因为它们决定了

00:03:34.379 --> 00:03:39.449
像素在形成新的输出图像过程中的重要性或权重

00:03:39.449 --> 00:03:41.129
在本边缘探测的案例中

00:03:41.129 --> 00:03:43.382
中心像素是最重要的

00:03:43.383 --> 00:03:48.085
然后才是顶部、底部和左右两侧距离最近的像素

00:03:48.085 --> 00:03:51.629
它们的权重为负 增加了图像的对比度

00:03:51.629 --> 00:03:54.604
四个角落距离中心像素最远

00:03:54.604 --> 00:03:57.709
在本例中 没有赋予它们任何权重

00:03:57.710 --> 00:03:59.990
因此 这个权重的求和 175

00:03:59.990 --> 00:04:03.520
就变成了输出图像中相同的 x y 位置的

00:04:03.520 --> 00:04:05.689
对应像素的值

00:04:05.689 --> 00:04:08.120
对原始图像中每个像素位置

00:04:08.120 --> 00:04:11.270
执行这个卷积步骤 直到

00:04:11.270 --> 00:04:13.850
得到完整的输出图像 其大小和输入图像

00:04:13.849 --> 00:04:17.509
差不多一样 但图像中的像素值为滤波后的值

00:04:17.509 --> 00:04:20.599
唯一需要考虑的一件事情是 在图像的边缘

00:04:20.600 --> 00:04:25.370
需要做什么 因为核无法很好地堆积在 3 乘 3 的值上

00:04:25.370 --> 00:04:28.649
下面 我们对这些高通滤波器类型再多做点练习

00:04:28.649 --> 00:04:31.000
然后开始编写自己的代码

