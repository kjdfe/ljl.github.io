WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.419
我们之前一直在使用一个预测状态函数

00:00:03.419 --> 00:00:06.576
利用当前状态和时间变化 dt

00:00:06.575 --> 00:00:11.820
并且基于恒定速度运动模型输出新的状态估计

00:00:11.820 --> 00:00:16.379
事实证明 恒定速度模型实际上是一个很好的简单模型

00:00:16.379 --> 00:00:19.500
时间变化非常小时效果更好

00:00:19.500 --> 00:00:23.065
现在 要在汽车移动时跟踪汽车的状态

00:00:23.065 --> 00:00:25.020
你必须重复调用这个函数

00:00:25.019 --> 00:00:28.359
在每个时间步长得到新的状态估计

00:00:28.359 --> 00:00:29.714
例如

00:00:29.714 --> 00:00:32.570
假设初始状态为

00:00:32.570 --> 00:00:37.140
位置 x 即零米位置 速度等于 50 米每秒

00:00:37.140 --> 00:00:39.060
我将这两个值放在列表中

00:00:39.060 --> 00:00:42.320
初始状态列表中 然后输出这个结果

00:00:42.320 --> 00:00:47.100
因此 初始状态为x等于零 速度等于50米/秒

00:00:47.100 --> 00:00:51.300
接下来 我想知道两秒钟后的下一个状态

00:00:51.299 --> 00:00:54.359
我会使用我的预测状态函数导入

00:00:54.359 --> 00:00:58.579
两秒钟的时间差的初始状态 我将这个状态称为

00:00:58.579 --> 00:01:03.384
est1 用于初始状态估计 我将输出这个结果

00:01:03.384 --> 00:01:08.879
我们的位置 x 现在在100米 速度保持在每秒50米

00:01:08.879 --> 00:01:11.709
然后 假设又过去了三秒钟

00:01:11.709 --> 00:01:14.379
我将再次调用预测状态函数

00:01:14.379 --> 00:01:18.222
这一次 我会导入最新的状态估计 state_est1

00:01:18.222 --> 00:01:23.069
和三秒钟的时差 我会输出这个值

00:01:23.069 --> 00:01:28.889
我们的位置现在是250米 速度保持恒定在每秒50米

00:01:28.890 --> 00:01:31.415
再过三秒钟呢？

00:01:31.415 --> 00:01:35.271
我必须导入我们最新的状态估计 state_est2

00:01:35.271 --> 00:01:39.974
和三秒钟的时差 我将输出这个值

00:01:39.974 --> 00:01:44.159
因此 我们实际上是一遍又一遍地调用同一行代码

00:01:44.159 --> 00:01:48.810
不过是将状态输入修改为最新的状态估计而已

00:01:48.810 --> 00:01:52.530
这种重复很无聊 因此这代码写得并不好

00:01:52.530 --> 00:01:57.144
作为程序员 你应该始终尽量避免不必要的重复

00:01:57.144 --> 00:01:59.339
让一辆车移动

00:01:59.340 --> 00:02:01.875
并且在移动时自动更新状态 岂不是要比

00:02:01.875 --> 00:02:04.500
手动写入相同代码 

00:02:04.500 --> 00:02:07.765
并重复跟踪汽车位置更好？

00:02:07.765 --> 00:02:13.000
我们可以在对象的帮助下自动跟踪状态

